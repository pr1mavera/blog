---
title: ES6编程风格
date: 2019-06-23
tags: 
 - 阿灯
---

## Iterator
在js中构造迭代器函数：
```js
let qq = function * () {
    yield '🍦'
    yield '🍔'
}
const iterator = qq();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
```
普通函数是惰性的输入一个返回值，造迭代属于惰性的输出多个值。真正的使用场景比较少，基本上开发时会基于 `async / await` 的语法糖使用。
::: warning 注意：
ES6中的新语法 `for in` 和 `for of` ，都是基于对象上的迭代器 `[Symbol Iterator]` 来进行遍历的，区别是 `for of` 会遍历目标本身，而 `for in` 会遍历目标本身**加上原型链上可以遍历的属性**，因此尽量不使用 `for in` 。另外，数组本身具有 `[Symbol Iterator]` 属性，因此可以遍历，如果想要遍历对象的属性，需要在对象上定义 `[Symbol Iterator]` 来描述属性遍历的行为。
:::

## Set 集合
相同的内容会被过滤掉，成员的值唯一
```js
let arr = new Set('🍔🍦🌭');
arr.add('🍪');
arr.add('🍪');

console.log(arr); // Set(4) { "🍔", "🍦", "🌭", "🍪" }
```

数组去重：
```js
const arr = [12, 34, 6, 98, 12, 6];
const res = [ ...new Set(arr) ]

console.log(res); // [12, 34, 6, 98]
```

## 模块化
+ 静态模块（模块名不能是变量）require导入和导出模块可以使用变量，ES6模块化不行
+ 声明式语法：只管声明，并不关心模块是如何加载过来的

ES6模块化 VS require模块化
+ 按需导入 VS 全局导入
+ 多点暴露 VS 全局暴露

## 默认值
ES6：
```js
function f (a = 1) {}
```
ES5:
```js
function f (a) {
    a = typeof a === 'undefined' ? 1 : a;
}
// ES5中常用的设置默认值一般是这样，但是这样是存在问题的，如果a本身是希望是个假值，那就呗覆盖了
a = a || 1
```
::: warning 注意：
ES6中设置默认值时只是判断了是否是undefined，是不会隐式强制类型转换的！！曾经在这方面吃过亏：执行函数传入一个空字符串进来，想要依靠ES6设置默认值来做一些健壮性处理，发现无效😂。
:::

## class
ES5实现继承：
```js
// 继承函数
function inherit (C, P) {
    var F = function () {}
    F.prototype = P.prototype
    C.prototype = new F(); // 临时构造函数

    C.prototype.constructor = C; // 修复constructor
    C.uper = P; // 储存超类
}

function Student (age, num) {
    Student.uber.call(this, age);
    this.num = num
}

inherit(Student, People);
```

ES6实现继承：
```js
class Child extends Parent {
    constructor() {
        super();
        this.value = 1;
    }
    get() {
        return this.value;
    }
}
```

## Babel（原名：6to5）
+ 拥抱ES*
+ 每一个特性---编译组件
+ 自由组装，自由组合
+ npm2下太大
+ 问题依然很多
