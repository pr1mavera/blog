---
title: 继承与原型
date: 2019-08-11
---

## 关键词

+ `new` ：JavaScript关键字，用于实例化一个对象
+ `构造函数` ：普通的函数使用 `new` 操作符调用，这个函数就被称为构造函数
+ `prototype` ：每一个**函数**都有一个叫 `prototype` 的公有并且不可枚举属性，指向的是这个构造函数的原型对象（注意是一个对象）
+ `constructor` ：函数上的 `prototype` 属性默认会有一个 `constructor` 属性，引用的是对象关联的函数，指的是对象由该函数 “构造”（这里需注意：实例化对象上本身并不存在 `constructor` 属性，只是从原型上委托过来的）
+ `__proto__` ：每个**实例对象**（ object ）都有一个私有属性（称之为 `__proto__` ）指向其的构造函数的原型对象（`prototype`），Function.__proto__ 指向自己！！
+ `[[Prototype]]` ：JavaScript对象的内部链接，指向该对象的原型，等同于非标准但许多浏览器实现的属性 `__proto__` 。可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。

## 牢记几个规律

1. 找 `__proto__` 时，就看这个东西的是什么类型的：  
    + `yideng.__proto__` ：yideng 是 Person 的实例，类型是 Person ，所以是 Perso.prototype
    + `Function.prototype.__proto__` ：Function.prototype说到底就是个对象，所以类型是 Object，所以是 Object.prototype
    + `Person.__proto__` / `Function.__proto__` / `Object.__proto__` ：都是函数，类型是 Function，所以是 Function.prototype
2. 找 `constructor` 时，切记 constructor 是绑在 prototype 上的，指向其原型对象的构造函数，依照委托原则，向上委托的是原型上的constructor
    + `Person.constructor` 实际上找到的是 `Function.prototype.constructor`
    + `yideng.constructor` 实际上找到的是 `Person.prototype.constructor`
    + 其他的以此类推


## 继承

基本思路：将子类的原型对象（prototype）的内部链接 [[Prototype]] 指向 父类的原型对象（prototype）（即子类的原型对象与父类的原型对象做关联），这一步操作可以通过 `Object.create()` 完成（`sub.prototype = Object.create(super.prototype)`）

ES5：
```js
function Super() {}
function Sub() {
    Super.call(this);
}

Sub.prototype = Object.create(Super.prototype);
Sub.prototype.constructor = Sub;

new Sub();
```
ES6：
```js
class Super {
    constructor() {}
}
class Sub extends Super {
    constructor() {
        super(); // 调用父类的constructor
    }
}

new Sub();
```
