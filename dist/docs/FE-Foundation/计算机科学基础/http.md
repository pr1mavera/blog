---
title: HTTP
date: 2019-08-13
---

请求模型：两个端点、两个动作  
client --- 请求 ---> Server  
client <--- 响应 --- Server  

+ 请求：告诉服务器想要的资源
+ 响应：服务器找到这份资源发出响应

**模型简单，机制复杂！！**

## 浏览器行为与HTTP协议
通信流程：
1. 输入网址并回车
2. 解析域名
3. 浏览器发送HTTP请求
4. 服务器处理请求
5. 服务器返回HTML响应
6. 浏览器处理HTML页面
7. 继续请求其他资源

客户端请求去google.com -> 翻越内外网关卡防火墙(路由器、直接接互联网，物理介质上需遵循PPP协议) -> 将域名通过DNS服务器翻译成IP -> 请求 -> google.com服务器集群(通过反向代理公用多个服务器)，收到请求，解析请求，生成资源并返回 -> 响应 -> 浏览器渲染

## HTTP协议语义详解

+ http是超文本传输协议，从服务器传输到本地浏览器的传输协议(大家都应该遵守的规范)，如网站的图片，CSS，JS。。。
+ http协议是由从客户端到服务器的请求和服务器到客户端的响应进行的**约束**和**规范**

HTTP/0.9(1991) --------> HTTP/1.0(1996) ---> HTTP/1.1(1999) ---------------> HTTP/2(2015)

::: warning 注意
http2向前兼容，HTTP3不向前兼容
:::
### 了解TCP/IP协议栈

<table>
    <tr>
        <td colspan="1">IOS/OSI分层</br>（标准化协议）</td>
        <td colspan="1">TCP/IP分层</br>（事实上的协议）</td>
        <td colspan="5">各层作用</td>
        <td colspan="5">各层协议</td>
    </tr>
    <tr>
        <td colspan="1">应用层</td>
        <td colspan="1" rowspan="3">应用层</td>
        <td colspan="5">为应用程序提供服务</td>
        <td colspan="5" rowspan="3">HTTP、Telnet、FTP、TFTP、DNS、SMTP</td>
    </tr>
    <tr>
        <td colspan="1">表示层</td>
        <td colspan="5">格式转化、数据加密</td>
    </tr>
    <tr>
        <td colspan="1">会话层</td>
        <td colspan="5">建立、管理和维护会话</td>
    </tr>
    <tr>
        <td colspan="1">传输层</td>
        <td colspan="1">传输层</td>
        <td colspan="5">建立、管理和维护端到端连接</td>
        <td colspan="5">TCP、UDP</td>
    </tr>
    <tr>
        <td colspan="1">网络层</td>
        <td colspan="1">网络层</td>
        <td colspan="5">IP选址及路由选择</td>
        <td colspan="5">IP、ICMP（ping）、RIP、IGMP</td>
    </tr>
    <tr>
        <td colspan="1">数据链路层</td>
        <td colspan="1">数据链路层</td>
        <td colspan="5">介质访问、链路管理</td>
        <td colspan="5">ARP 与 RARP（用于维护MAC与IP的关系）、IEEE802.3、PPP、CSMA/CD</td>
    </tr><tr>
        <td colspan="1">物理层</td>
        <td colspan="1">物理层</td>
        <td colspan="5">物理层</td>
        <td colspan="5">FE自协商、Manchester、MLT-3、4A、PAM5</td>
    </tr>
</table>

1. 应用层
    + 为用户提供所需要的各种服务，如：HTTP、FTP、DNS、SMTP(e-mail) 。。。
2. 传输层(socket)
    + 为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性
    + 该层定义了两个主要的协议：传输控制协议(TCP，可靠) 和 用户数据报协议(UDP，不可靠)
3. 网络层
    + 主要解决主机到主机的通信问题，IP协议是网际互联层最重要的协议  
---------------- 以下为硬件层 ----------------
物理层 数据链路层
4. 网络接口层
    + 负责监视数据在主机和网络之间的交换

::: warning 注意：
+ 目前普遍应用版本 `HTTP1.1`
+ 正在逐步向 `HTTP2` 迁移
+ `HTTP` 默认端口号为 `80`
+ `HTTPS` 默认端口号为 `443`
:::

### HTTP 的工作过程

一次HTTP操作成为一个事务(分步串行操作，要么全部做完，要么算失败)，包括请求和响应，
1. 首先客户端与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始
2. 建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号，后面是MIME信息包括请求装饰符、客户端信息和可能的内容(请求报文)
3. 服务器接到请求，给予相应的响应(响应报文)，格式为一个状态行，
4. 客户端接收到服务器返回的信息，浏览器显示，客户端与服务器断开连接

!! *注意*：**如果在以上过程中任何一步出现错误，那么错误信息将返回到客户端** !!

### 请求与响应

+ HTTP请求组成：请求行、消息报头(k-v格式)、请求正文
+ HTTP响应组成：状态行、消息报头、响应正文
+ 请求行组成：以一个方法符号开头(GET、POST 。。。) ，后面跟着请求的URL和协议的版本
+ 状态行组成：服务器HTTP协议的版本，服务器发回的响应状态代码(404、200 。。。) 和其文本描述

::: warning 注意：
请求：
1. 请求行的结束，两个字符：
    * windows:  **回车符**(/r)，**换行符**(/n)
    * Linux:  **换行符**(/n)
2. 报文头和报文体的连接：连续两个**回车符**和**换行符**

响应：
1. 响应头和响应体的连接： **7f** (ASCII码上的删除符号，是不可见字符)
2. 响应体的结束： **0** (ASCII码上的空字符，表示文本文件的结束)
:::

### HTTP 的请求方法
* `GET` 请求获取 request-URL 所标识的资源
* `POST` 在 request-URL 所标识的资源后附加新的数据
* `HEAD` 请求获取由 request-URL 所标识的资源的响应消息报头
* `PUT` 请求服务器存储一个资源，并用 request-URL 作为其标识
* `DELETE` 请求服务器删除 request-URL 所标识的资源
* `CONNECT` 请求服务器回送收到的请求信息，主要用户测试或诊断
* `OPTIONS` HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器
* `TRACE` 请求查询服务器的性能，或者查询与资源相关的选项和需求

### HTTP 状态码

由三位数字组成，第一位定义响应的类别，且有5种可能：
+ 1xx: 表示请求收到，但是未处理完，为了不超时，返回一个指示信息
+ 2xx: 成功 -- 表示请求已被成功接收、理解、接受
    + 200: 请求被正常处理
    + 204: 请求被受理但是没有资源可以返回
    + 206: 客户端只是请求资源的一部分，服务器只对请求的部分资源进行 `GET` 方法，相应报文中通过Content-Range指定范围的资源
+ 3xx: 重定向 -- 要完成请求必须进行更进一步的操作
    + 301: 永久性重定向
    + 302: 临时重定向
    + 303: 与302状态码有相似功能，只是他希望客服端在请求一个URL的时候，能通过 `GET` 方法重定向到另一个URL上
    + 304: 发送附带条件的请求时，条件不满足时返回，与重定向无关
    + 307: 临时重定向，与302类似，只是强制要求使用 `POST` 方法
+ 4xx: 客户端错误 -- 请求有语法错误或请求无法实现
    + 400: 请求报文语法有误，服务器无法识别
    + 401: 请求需要认证
    + 403: 请求的对应资源禁止被访问
    + 404: 服务器无法找到对应资源
+ 5xx: 服务却错误 -- 服务却未能实现合理的请求，范围很广：从web服务器 到 API接口 到 数据库错误 到 网关错误
    + 500: 服务器内部错误
    + 503: 服务器正忙

### 常见报头

+ 通用首部字段（请求报文与响应报文都会使用的首部字段）
    + Date: 创建报文时间
    + Connection: 连接的管理
    + Cache-Control: 缓存的控制
    + Transfer-Encoding: 报文主体的传输编码方式
+ 请求首部字段（请求报文会使用的首部字段）
    + Host: 请求资源所在服务器
    + Referer: 来源，当前页面的上一页
    + Accept: 可处理的媒体类型
    + Accept-Encoding: 可接受的内容编码（响应体是否要压缩）
    + Accept-Language: 可接受的自然语言
    + User-Agent: 识别浏览器版本（在之前浏览器实现规范不统一的时代，为了兼容性处理）
+ 响应首部字段（响应报文会使用的首部字段）
    + Accept-Ranges: 可接受的字节范围
    + Location: 令客户端重新定向到的URI
    + Server: HTTP服务器的安装信息
+ 实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）
    + Allow: 资源可支持的HTTP方法
    + Content-Type: 实体主类的类型
    + Content-Encoding: 实体主体适用的编码方式
    + Content-Language: 实体主体的自然语言
    + Content-Length: 实体主体的的字节数
    + Content-Range: 实体主体的位置范围，一般用于发出部分请求时使用

## cookie & Session

为解决服务器对于客户端的身份识别问题，相当于建立客户端到服务器的持久会话状态，客户端第一次访问服务器时，服务器通过Set-Cookie将信息存至客户端浏览器，当下次客户端访问服务器时会带上这些Cookie，服务器就可以识别客户端的信息了 ----> **维护会话，识别身份**

+ `Cookie` 是保存在客户端的小段文本，随客户端每个请求发送该URL下所有 `cookie` 到服务器
+ `Session` 是保存在服务器端的(相当于一个小型数据库) ，通过唯一的值 `sessionID` 来区别每一个用户， `sessionID` 随每个连接请求发送到服务器，服务器根据 `sessionID` 来识别客户端，通过 `session` 的 `key` 获取 `session` 的值

## HTTP缓存机制

如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求

客户端 ------ GET xxx ------> 服务器  
客户端 <------ 200 OK ------ 服务器  
客户端 ------ GET xxx ------> 服务器  
客户端 <------ 304 Not Modify ------ 服务器  

+ Date: 当前请求资源的国际标准时间(比北京时间晚8小时)
+ Expires: 包含日期/时间， 即在此时候之后，响应过期
+ Etag: 类似于资源指纹，每一次给定URL中的资源更改，则一定要生成新的Etag值
+ Last-Modified: 资源最后一次修改时间

优点：
1. 减少响应延迟
2. 减少网络带宽消耗

缓存策略：
+ 强制缓存：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接接用缓存，不在时间内，执行比较缓存策略
+ 比较缓存：将缓存信息的 `Etag` (If-None-Match) 和 `Last-Modified` (If-Modified-Since) 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存

具体流程：  
第一次请求：
![第一次请求](/blog/img/cs/once.jpeg)
第二次请求：
![第二次请求](/blog/img/cs/twice.jpeg)
